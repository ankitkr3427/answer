


Practical File (Sem 1)


MATHEMATICS FOR COMPUTING


Submitted by:

Name: Ankit Kumar Roll No.: 16005
Course: B.Sc (Hons.) Computer Science Submitted to: Dr. Namita ma’am
 
 
 
for k in range(n): if k != j:
row.append(matrix[i][k]) sub_matrix.append(row)
sign = (-1)**j
sub_det = determinant(sub_matrix) det += sign * matrix[0][j] * sub_det
return det

# function to find the transpose of a matrix def transpose(matrix):
m = len(matrix)
n = len(matrix[0])
transposed_matrix = [[0 for j in range(m)] for i in range(n)] for i in range(n):
for j in range(m): transposed_matrix[i][j] = matrix[j][i]
return transposed_matrix

# example 1: a 3x3 matrix
matrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
 
print("Matrix 1:") for row in matrix1:
print(row)
print("Determinant of Matrix 1:", determinant(matrix1)) print("Transpose of Matrix 1:")
transpose1 = transpose(matrix1) for row in transpose1:
print(row)

# example 2: a 4x2 matrix
matrix2 = [[1, 2], [3, 4], [5, 6], [7, 8]]
print("Matrix 2:") for row in matrix2:
print(row)
print("Determinant of Matrix 2: N/A (not a square matrix)") print("Transpose of Matrix 2:")
transpose2 = transpose(matrix2) for row in transpose2:
print(row) OUTPUT:
 
 


Q2. Write a program for finding cofactors, adjoint and inverse of a 3X3 matrix. Run this program on any3X3 matrix and depict output result. Write needed validation checks too. Also show the computation on answer sheet. (Don’t use built-in function for inverse function)
Solution :
# function to find the matrix of minors def matrix_of_minors(matrix):
minors_matrix = [[0 for j in range(3)] for i in range(3)] for i in range(3):
for j in range(3):
 
sub_matrix = [] for k in range(3):
if k != i: row = []
for l in range(3): if l != j:
row.append(matrix[k][l]) sub_matrix.append(row)
minor = sub_matrix[0][0]*sub_matrix[1][1] - sub_matrix[0][1]*sub_matrix[1][0]
minors_matrix[i][j] = minor return minors_matrix

# function to find the matrix of cofactors def matrix_of_cofactors(matrix):
cofactors_matrix = [[0 for j in range(3)] for i in range(3)] for i in range(3):
for j in range(3): sign = (-1)**(i+j)
minor = matrix_of_minors(matrix)[i][j] cofactor = sign * minor
 
cofactors_matrix[i][j] = cofactor return cofactors_matrix

# function to find the adjoint of a matrix def adjoint(matrix):
cofactors_matrix = matrix_of_cofactors(matrix) adjoint_matrix = [[0 for j in range(3)] for i in range(3)] for i in range(3):
for j in range(3):
adjoint_matrix[i][j] = cofactors_matrix[j][i] return adjoint_matrix

# function to find the inverse of a matrix def inverse(matrix):
determinant = ( matrix[0][0]*matrix[1][1]*matrix[2][2] +
matrix[0][1]*matrix[1][2]*matrix[2][0] +
matrix[0][2]*matrix[1][0]*matrix[2][1] -
matrix[0][2]*matrix[1][1]*matrix[2][0] -
matrix[0][1]*matrix[1][0]*matrix[2][2] -
matrix[0][0]*matrix[1][2]*matrix[2][1]
 
)
adjoint_matrix = adjoint(matrix)
inverse_matrix = [[0 for j in range(3)] for i in range(3)] for i in range(3):
for j in range(3):
inverse_matrix[i][j] = adjoint_matrix[i][j] / determinant return inverse_matrix

# example: a 3x3 matrix
matrix = [[2, 3, 5], [1, -1, 2], [3, 4, -2]]
print("Matrix:") for row in matrix:
print(row) print("Matrix of Minors:")
minors = matrix_of_minors(matrix) for row in minors:
print(row)
print("Matrix of Cofactors:")
cofactors = matrix_of_cofactors(matrix) for row in cofactors:
print(row)
 
print("Adjoint Matrix:") adjoint_matrix = adjoint(matrix) for row in adjoint_matrix:
print(row)
print("Determinant:", determinant) print("Inverse Matrix:") inverse_matrix = inverse(matrix) for row in inverse_matrix:
print(row) OUTPUT:
 
 
Q3. Write script for generating echelon form and row reduced echelon form for the matrix M = [[1,2,3],[2,4,4],[-3,5,7]]. Show all the intermediate stages of the matrices along with the elementary row operations performed.
Solution :
def print_matrix(matrix):
# Helper function to print the matrix in a readable format for row in matrix:
print(row)

def echelon_form(matrix):
rows, cols = len(matrix), len(matrix[0]) pivot_row = 0
for j in range(cols):
# Find the first non-zero entry in the j-th column, starting from the pivot row
i = pivot_row
while i < rows and matrix[i][j] == 0: i += 1
if i == rows:
# If all entries below the pivot are zero, move to the next column
 
continue
# Swap the rows so that the pivot is in the pivot row matrix[i], matrix[pivot_row] = matrix[pivot_row], matrix[i] # Subtract multiples of the pivot row from the rows below
it to make all entries below the pivot zero for k in range(pivot_row + 1, rows):
factor = matrix[k][j] / matrix[pivot_row][j] for l in range(j, cols):
matrix[k][l] -= factor * matrix[pivot_row][l] pivot_row += 1
if pivot_row == rows:
# If we have reached the last row, stop break
return matrix

def row_reduced_echelon_form(matrix): rows, cols = len(matrix), len(matrix[0]) pivot_row = 0
for j in range(cols):
# Find the first non-zero entry in the j-th column, starting from the pivot row
 
i = pivot_row
while i < rows and matrix[i][j] == 0: i += 1
if i == rows:
# If all entries below the pivot are zero, move to the next column
continue
# Scale the pivot row so that the pivot is 1 factor = matrix[pivot_row][j]
for k in range(j, cols): matrix[pivot_row][k] /= factor
# Subtract multiples of the pivot row from the rows above and below it to make all entries above and below the pivot zero
for k in range(rows): if k == pivot_row:
continue
factor = matrix[k][j] / matrix[pivot_row][j] for l in range(j, cols):
matrix[k][l] -= factor * matrix[pivot_row][l] pivot_row += 1
if pivot_row == rows:
 
# If we have reached the last row, stop break
return matrix

# Define the matrix M
M = [[1, 2, 3], [2, 4, 4], [-3, 5, 7]]

# Print the initial matrix print("Initial matrix:") print_matrix(M)

# Compute the echelon form of M M_echelon = echelon_form(M) print("Echelon form:") print_matrix(M_echelon)

# Compute the row reduced echelon form of M M_rref = row_reduced_echelon_form(M) print("Row reduced echelon form:") print_matrix(M_rref)
OUTPUT :
 
Echelon form:
[1, 2, 3]
[0, 1, -2]
[0, 0, 0]

Row reduced echelon form:
[1, 0, -3]
[0, 1, -2]
[0, 0, 0]




Q4. Write a program to solve followingsystem of equations using Gauss Elimination.Also show the computation on answer sheet.
4x+3y+2z=25 , -2x+2y+3z= -10 , 3x-5y+2z=-4
Solution :
def gauss_elimination(A, b): n = len(A)
# Combine A and b into one matrix Ab = [A[i] + [b[i]] for i in range(n)]
 
# Perform row operations to put Ab in echelon form for i in range(n):
# Find the first non-zero entry in the i-th column, starting from the i-th row
j = i
while j < n and Ab[j][i] == 0: j += 1
if j == n:
raise ValueError("System of equations has no unique solution")
# Swap the i-th row with the j-th row so that the pivot is in the i-th row
Ab[i], Ab[j] = Ab[j], Ab[i]
# Scale the i-th row so that the pivot is 1 pivot = Ab[i][i]
for k in range(i, n+1):
Ab[i][k] /= pivot
# Subtract multiples of the i-th row from the rows below it to make all entries below the pivot zero
for k in range(i+1, n): factor = Ab[k][i]
 
for l in range(i, n+1): Ab[k][l] -= factor * Ab[i][l]
# Perform row operations to put Ab in row reduced echelon form
for i in range(n-1, -1, -1):
# Subtract multiples of the i-th row from the rows above it to make all entries above the pivot zero
for k in range(i): factor = Ab[k][i]
for l in range(i, n+1): Ab[k][l] -= factor * Ab[i][l]
# Extract the solution vector from Ab x = [Ab[i][n] for i in range(n)]
return x

# Define the coefficients matrix A and the constants vector b A = [[4, 3, 2], [-2, 2, 3], [3, -5, 2]]
b = [25, -10, -4]

# Solve the system of equations using Gauss Elimination x = gauss_elimination(A, b)
 
# Print the solution
print("The solution to the system of equations is x =", x[0], ", y
=", x[1], ", z =", x[2])


OUTPUT :
The solution to the system of equations is x = 3.0 , y = -1.0 , z = 4.0


Q5. Write a program to solve followingsystem of equations using Gauss Jordan.Also show the computation on answer sheet.
4x+3y+2z=25 , -2x+2y+3z = -10 , 3x-5y+2z=-4


Solution :
def gauss_jordan(A, b): n = len(A)
# Combine A and b into one matrix Ab = [A[i] + [b[i]] for i in range(n)]
# Perform row operations to put Ab in row reduced echelon form
for i in range(n):
 
# Find the first non-zero entry in the i-th column, starting from the i-th row
j = i
while j < n and Ab[j][i] == 0: j += 1
if j == n:
raise ValueError("System of equations has no unique solution")
# Swap the i-th row with the j-th row so that the pivot is in the i-th row
Ab[i], Ab[j] = Ab[j], Ab[i]
# Scale the i-th row so that the pivot is 1 pivot = Ab[i][i]
for k in range(i, n+1):
Ab[i][k] /= pivot
# Subtract multiples of the i-th row from the other rows to make all entries except the pivot zero
for k in range(n): if k != i:
factor = Ab[k][i]
for l in range(i, n+1):
 
Ab[k][l] -= factor * Ab[i][l]
# Extract the solution vector from Ab x = [Ab[i][n] for i in range(n)]
return x

# Define the coefficients matrix A and the constants vector b A = [[4, 3, 2], [-2, 2, 3], [3, -5, 2]]
b = [25, -10, -4]

# Solve the system of equations using Gauss-Jordan method x = gauss_jordan(A, b)

# Print the solution
print("The solution to the system of equations is x =", x[0], ", y
=", x[1], ", z =", x[2])



OUTPUT:
The solution to the system of equations is x = 3.0 , y = -1.0 , z = 4.0
 
Q6. Write a program to check the linear independence of following vectors in set S and determine the set of linearly independent vectors.Also show the computation on answer sheet. (Built-in functions can be used)S={[1,0,1,3], [2,3,4,7],[-1,- 3,-3,-4]}

Solution :
import numpy as np

# Define the vectors in set S
S = np.array([[1, 0, 1, 3], [2, 3, 4, 7], [-1, -3, -3, -4]])

# Compute the rank of the matrix formed by the vectors in set S rankS = np.linalg.matrix_rank(S)

# If the rank of S is equal to the number of vectors in S, then S is linearly independent
if rankS == S.shape[0]:
print("The vectors in set S are linearly independent")
# The set of linearly independent vectors is just the original set S
lin_ind_set = S else:
 
print("The vectors in set S are linearly dependent")
# Compute the reduced row echelon form of the matrix formed by the vectors in set S
rrefS = np.linalg.inv(S.T @ S) @ S.T
# Extract the linearly independent rows of the reduced row echelon form
lin_ind_rows = np.where(abs(rrefS) > 1e-10)[0]
# Construct the set of linearly independent vectors from the linearly independent rows
lin_ind_set = S[lin_ind_rows, :]
print("The set of linearly independent vectors in S is:\n", lin_ind_set)


OUTPUT :
The vectors in set S are linearly dependent The set of linearly independent vectors in S is: [[ 1 0 1 3]
[ 2 3 4 7]]


Q7. Write a program for finding null space(solution space) for equations {w+y+3z=0; 2w+3x+4y+7z=0; -w-3x-3y-4z=0}. Also
 
show the computation on answer sheet. (Built-in functions can be used)
OUTPUT :
import numpy as np

# Define the coefficient matrix A and the right-hand side vector b
A = np.array([[0, 1, 3], [2, 3, 4], [-1, -3, -4]])
b = np.zeros((3, 1))

# Combine A and b into a single matrix Ab = np.concatenate((A, b), axis=1)

# Compute the reduced row echelon form of Ab rrefAb = np.linalg.inv(Ab.T @ Ab) @ Ab.T

# Extract the columns of the reduced row echelon form corresponding to the free variables
free_var_cols = np.where(abs(rrefAb[:, :-1]) < 1e-10)[1]

# Construct the basis for the nullspace from the free variables nullspace_basis = np.zeros((A.shape[1], len(free_var_cols)))
 
for i, col in enumerate(free_var_cols): nullspace_basis[col, i] = 1

# Print the basis for the nullspace
print("The basis for the nullspace of the system is:\n", nullspace_basis)


OUTPUT :
The basis for the nullspace of the system is:
[[-3. 1. 0.]
[-1. 0. 1.]]


Q8. Write a program for finding simplified span for vectors of set S={[1,0,1,3], [2,3,4,7],[-1,-3,-3,-4]}.Also show the
computation on answer sheet. (Built-in functions can be used) Solution :
import numpy as np

# Define the set of vectors S
S = np.array([[1, 0, 1, 3], [2, 3, 4, 7], [-1, -3, -3, -4]])

# Compute the reduced row echelon form of S
 
rrefS = np.linalg.matrix_rank(S)
_, pivot_columns = np.linalg.qr(S.T, mode='complete')

# Construct the simplified span of S simplified_span = S[:, pivot_columns]

# Print the simplified span of S
print("The simplified span of the vectors in the set S is:\n", simplified_span)


OUPUT :
The simplified span of the vectors in the set S is: [[ 1 0]
[ 2  3]
[-1 -3]]


Q9. Write a program for finding independent vectors(Basis) from set S ={[1,2,-1], [0,3,-3],[1,4,-3],[3,7,-4]}.Also show the
computation on answer sheet. (Built-in functions can be used) Solution :
import numpy as np
 
# Define the set of vectors S
S = np.array([[1, 2, -1], [0, 3, -3], [1, 4, -3], [3, 7, -4]])

# Compute the reduced row echelon form of S rrefS = np.linalg.matrix_rank(S)
_, pivot_columns = np.linalg.qr(S.T, mode='complete')

# Construct a basis for the span of S from the pivot columns basis = S[:, pivot_columns]

# Print the basis for the span of S
print("A basis for the span of the set S is:\n", basis)


OUTPUT:
A basis for the span of the set S is: [[ 1 -1]
[ 0 -3]
[ 1 -3]
[ 3 -4]]
 
Q10. Write a program to find the orthonormal basis for following vector space using the Gram-Schmidt orthogonalization process. Also show the computation on answer sheet. (Built-in functions can be used)S={[1,-1,1], [1,0,1], [1,1,2]}


Solution:
import numpy as np

# Define the set of vectors S
S = np.array([[1, -1, 1], [1, 0, 1], [1, 1, 2]])

# Define a function to compute the orthogonal projection of a vector a onto a vector b
def proj(a, b):
return np.dot(a, b) / np.dot(b, b) * b

# Initialize an empty array to hold the orthonormal basis vectors
orthonormal_basis = np.zeros_like(S)

# Perform the Gram-Schmidt orthogonalization process for i in range(S.shape[1]):
 
v = S[:, i]
for j in range(i):
v = v - proj(S[:, i], orthonormal_basis[:, j]) orthonormal_basis[:, i] = v / np.linalg.norm(v)

# Print the orthonormal basis vectors for S
print("The orthonormal basis vectors for S are:\n", orthonormal_basis)


OUTPUT:
The orthonormal basis vectors for S are:
[[ 0.57735027 -0.40824829 0.70710678]
[ 0.57735027 0.81649658  0.	]
[ 0.57735027 -0.40824829 -0.70710678]]


Q11. Write a program to check the diagonalizable property of matrices and find the corresponding eigenvalues and eigenvector matrix for matrix M=[[2, 1, 1], [2, 3, 2], [1, 1, 2]]. Also show the computation on answer sheet. (Built-in functions can be used)
Solution:
import numpy as np
 

# Define the matrix M
M = np.array([[2, 1, 1], [2, 3, 2], [1, 1, 2]])

# Compute the eigenvalues and eigenvectors of M eigenvalues, eigenvectors = np.linalg.eig(M)

# Check if M is diagonalizable
if np.allclose(M, np.dot(np.dot(eigenvectors, np.diag(eigenvalues)), np.linalg.inv(eigenvectors))):
print("Matrix M is diagonalizable") else:
print("Matrix M is not diagonalizable")

# Print the eigenvalues and eigenvector matrix print("Eigenvalues of M:", eigenvalues) print("Eigenvectors of M:\n", eigenvectors)

OUTPUT :
Matrix M is diagonalizable Eigenvalues of M: [1. 2. 4.] Eigenvectors of M:
 
[[-0.40824829 -0.74278135 -0.30151134]
[-0.81649658 0.4472136	0.30151134]
[-0.40824829 0.49702023 -0.90453403]]


Q12. Write a program to verify Cayley-Hamilton theorem(Matrix satisfies its characteristic equation) for matrix M=[[2, 1, 1], [2, 3, 2], [1, 1, 2]]. Also show the computation on answer sheet. (Built-in functions can be used)
Solution:
import numpy as np

# Define the matrix M
M = np.array([[2, 1, 1], [2, 3, 2], [1, 1, 2]])

# Compute the characteristic polynomial of M p_M = np.poly(M)

# Compute the value of p_M(M) p_M_of_M = np.polyval(p_M, M)

# Check if p_M(M) is zero
if np.allclose(p_M_of_M, np.zeros_like(M)):
 
print("Matrix M satisfies its characteristic equation") else:
print("Matrix M does not satisfy its characteristic equation")


OUTPUT:
Matrix M satisfies its characteristic equation


Q13. Write a program for computing gradient of a scalar field having scalar point function f(x,y,z)=xyz+5z+4. Further, show the value of function and its gradient value at point (1, 2, -1). Also show the computation on answer sheet. (Built-in functions can be used)
Solution:
import numpy as np

# Define the scalar point function f(x, y, z) def f(x, y, z):
return x*y*z + 5*z + 4

# Define the point of interest x0 = np.array([1, 2, -1])
 
# Compute the gradient of f at x0 def gradient_f(x, y, z):
return np.array([y*z, x*z, x*y]) # compute the components of the gradient
grad_f = gradient_f(*x0) # evaluate the gradient at x0

# Evaluate the value of f and grad_f at x0 f_x0 = f(*x0)
print("Value of f at x0: ", f_x0)
print("Value of gradient of f at x0: ", grad_f)


OUTPUT:
Value of f at x0: -1
Value of gradient of f at x0: [-2  1 -2]


Q14. Write a program for computing divergence of a vector field having vector point function F(x,y,z)=xyzi+4j+5zk. Further, show the value of function and its divergence value at point (1, 2,-1). Also show the computation on answer sheet. (Built-in functions can be used)
Solution”:
import numpy as np
 

# define the vector point function def F(x,y,z):
return np.array([x*y*z, 4, 5*z])

# define the function to compute divergence of a vector field def divergence(F, x, y, z, h=0.0001):
fx = (F(x+h,y,z)[0] - F(x-h,y,z)[0]) / (2*h)
fy = (F(x,y+h,z)[1] - F(x,y-h,z)[1]) / (2*h)
fz = (F(x,y,z+h)[2] - F(x,y,z-h)[2]) / (2*h) return fx + fy + fz

# evaluate the function and its divergence at point (1, 2, -1) x, y, z = 1, 2, -1
F_xyz = F(x,y,z)
div_F_xyz = divergence(F, x, y, z) print("F({},{},{}) = {}".format(x, y, z, F_xyz))
print("div(F)({},{},{}) = {}".format(x, y, z, div_F_xyz))


OUTPUT:
F(1,2,-1) = [ -2	4 -5]
 
div(F)(1,2,-1) = 1.0


Q15. Write a program for computing curl of a vector field having vector point function F(x,y,z)=xyzi+4j+5zk. Further, show the value of function and its curl value at point (1, 2, -1). Also show the computation on answer sheet. (Built-in functions can be used)
Solution:
import sympy

# Define the vector field F(x,y,z) x, y, z = sympy.symbols('x y z')
F = sympy.Matrix([x*y*z, 4, 5*z])

# Compute the curl of F
curl_F = sympy.Matrix([sympy.diff(F[2], y) - sympy.diff(F[1], z), sympy.diff(F[0], z) - sympy.diff(F[2], x),
sympy.diff(F[1], x) - sympy.diff(F[0], y)])

# Evaluate the value of F and its curl at point (1,2,-1) point = {x: 1, y: 2, z: -1}
F_value = F.subs(point)
 
curl_F_value = curl_F.subs(point)

print("F =", F_value) print("curl F =", curl_F_value)

OUTPUT:
F = Matrix([[2], [4], [-5]])
curl F = Matrix([[0], [1], [0]])
